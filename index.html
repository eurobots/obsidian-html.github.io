<!DOCTYPE html>

<html lang="en">

        <head>
                <!-- Page information -->
                <meta charset="UTF-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <link rel="shortcut icon" href="/favicon.ico" />

                <!-- Set title -->
                <title>Example Site</title>

                <!-- Includes -->
                <link rel="stylesheet" href="/main.css" />

                <script>
                        // add prefix to hash to avoid scrolling
                        if (window.location.hash != '' && window.location.hash.substr(1)[0] != '!'){
                                window.location.hash = '!' + window.location.hash.substr(1);
                        }
                </script>
        </head>

<body onload="LoadPage();">
<div id="header" class="header">
        <a href="/" id="homelink">Example Site</a>
</div>
<div class="container-wrapper">
        <div class="container">
        <h1 id="example-site">Example Site</h1>
<p>This is an example project showing off the capabilities of <a href="https://github.com/obsidian-html/obsidian-html" class="external-link" class="external-link">Obsidian-html</a>.   </p>
<p>In short, this code converts Obsidian notes to proper markdown, and then spits out a site like this. <a href="https://github.com/obsidian-html/obsidian-html.github.io/tree/main/md" class="external-link">You can find the generated markdown here</a>.   </p>
<p>See also this site, which uses purely this code: <a href="https://www.devfruits.com" class="external-link">devfruits.com</a>.   </p>
<blockquote>
<p>All credit to this site's design goes to Andy Matuschak. I basically <a href="https://notes.andymatuschak.org/Evergreen_notes" class="external-link">stole his design</a> because I think it is perfect.   </p>
</blockquote>
<h1 id="basics">Basics</h1>
<div class="codehilite"><pre><span></span><code>One enter
translates to
a new line, just like in Obsidian!
</code></pre></div>

<p>One enter <br />
translates to <br />
a new line, just like in Obsidian!   </p>
<h1 id="links">Links</h1>
<h2 id="obsidian-type-links">Obsidian type links</h2>
<p><code>[[Simple Obsidian-type Link]]</code> translates too: <br />
<a href="/Simple Obsidian-type Link.html">Simple Obsidian-type Link</a>   </p>
<p>Aliasing also works, <code>[[Simple Obsidian-type Link|Same link as before]]</code>: <br />
<a href="/Simple Obsidian-type Link.html">Same link as before</a>   </p>
<p>As does linking to chapters <code>[[Long long page#Chapter of interest]]</code> <br />
<a href="/Long long page.html#chapter-of-interest">Long long page#Chapter of interest</a>   </p>
<h2 id="proper-markdown-links">Proper markdown links</h2>
<p>There is a setting that forces Obsidian to use proper markdown notation. So this is also supported:   </p>
<p><code>[Proper markdown link](proper%20markdown)</code> <br />
<a href="/proper markdown.html">Proper markdown link</a>   </p>
<p>Note that spaces must be encoded in proper markdown links.   </p>
<h2 id="link-awareness">Link awareness</h2>
<p>An external links show up the little icon to show it: <br />
<a href="https://github.com/obsidian-html/obsidian-html" class="external-link" class="external-link">https://github.com/obsidian-html/obsidian-html</a>   </p>
<p>When linking to new notes, and not creating them, the link will be replaced with "not_created.html", and the link will be color coded by adding <code>class="nonexistent-link"</code> to the a href:   </p>
<p><a href="/not_created.html" class="nonexistent-link">In the end I never created this note</a>   </p>
<h2 id="link-to-non-markdown-files">Link to non-markdown files</h2>
<p>Image files and other non-markdown files local to the given root folder get copied over to the output. Take for example: <a href="textfile.txt" class="external-link">test textfile</a>.   </p>
<p>Note that Obsidian type links will always be appended with .md if this is missing.    </p>
<p>This is the default behavior of Obsidian. You can work around this, but when you do, it is impossible to determine with 100% certainty which file is linked to.    </p>
<p>If you want to link to files that are not markdown, use proper markdown links:   </p>
<div class="codehilite"><pre><span></span><code><span class="p">[[</span><span class="n">textfile</span><span class="p">.</span><span class="n">txt</span><span class="p">]]</span> <span class="o">--&gt;</span> <span class="p">[</span><span class="n">textfile</span><span class="p">.</span><span class="n">txt</span><span class="p">](</span><span class="n">textfile</span><span class="p">.</span><span class="n">txt</span><span class="p">.</span><span class="n">md</span><span class="p">)</span>
<span class="p">[</span><span class="n">textfile</span><span class="p">.</span><span class="n">txt</span><span class="p">](</span><span class="n">textfile</span><span class="p">.</span><span class="n">txt</span><span class="p">)</span> <span class="o">--&gt;</span> <span class="p">[</span><span class="n">textfile</span><span class="p">.</span><span class="n">txt</span><span class="p">](</span><span class="n">textfile</span><span class="p">.</span><span class="n">txt</span><span class="p">)</span>
</code></pre></div>

<h1 id="images">Images</h1>
<h2 id="obsidian-type-image-links">Obsidian type image links</h2>
<p><code>![[Resources/img/obsidian-html-logo-sq.png]]</code> <br />
<img alt="" src="Resources/img/obsidian-html-logo-sq.png" />   </p>
<h2 id="proper-markdown-image-links">Proper markdown image links</h2>
<p><code>![](Resources/img/obsidian-html-logo.png)</code> <br />
<img alt="" src="Resources/img/obsidian-html-logo.png" />   </p>
<h1 id="code-blocks">Code blocks</h1>
<p>This is built into python-markdown, and enabled by default. <br />
Any codeblock or codeline is excempt from modification because they get cut out of the markdown code in the beginning, and then reinserted right before the html is created. <br />
<a href="/Code block examples.html">Code block examples</a>   </p>
<h1 id="lists">Lists</h1>
<p>No newline is needed in between paragraphs and lists. This is standard in Obsidian. The fix is implemented by adding in the newline for the generated markdown.   </p>
<div class="codehilite"><pre><span></span><code>Textblock
<span class="k">-</span> List item
</code></pre></div>

<p>Is converted to:   </p>
<div class="codehilite"><pre><span></span><code>Textblock

<span class="k">-</span> List item
</code></pre></div>

<p><em>Example</em>:  <br />
Textblock   </p>
<ul>
<li>List item   </li>
</ul>
<h1 id="html-tweaks">Html tweaks</h1>
<p>Quite some work has been put into the usability of the html website interface. Though if you don't like it, simply change <code>src/template.html</code> out for something more basic - or more fancy.   </p>
<h2 id="click-backs">Click-backs</h2>
<p>When you open a whole chain of notes, you'll be scrolled rightward to keep up.  <br />
Clicking on a click-back corner will align that note with the left of the screen. This allows you to move back/forward one note at a time.    </p>
<p>Of course, the scrollbar and arrow keys are available too as methods of navigation.   </p>
<p>The clickbacks are in the top right corner of every note: <br />
<img alt="" src="Pasted%20image%2020211012013603.png" />   </p>
<h2 id="closing-tabs">Closing tabs</h2>
<p>When you click on a new link in an earlier tab, all the open tabs after it will be closed.   </p>
<h2 id="notice-the-url">Notice the url</h2>
<p>There is a <code>?path=</code> part in the link that allows you to open the same set of tabs after a refresh.    </p>
<h1 id="not-supported">Not supported</h1>
<h2 id="code-inclusion">Code inclusion</h2>
<p>Code inclusion in Obsidian allows you to include a note into another note, or just a part of a note in another note.    </p>
<p>It uses the same link syntax as images:   </p>
<div class="codehilite"><pre><span></span><code><span class="o">!</span><span class="p">[[</span><span class="n">my</span><span class="w"> </span><span class="n">note</span><span class="p">]]</span><span class="w"></span>
<span class="o">!</span><span class="p">[[</span><span class="n">my</span><span class="w"> </span><span class="n">note</span><span class="err">#</span><span class="n">only</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">chapter</span><span class="p">]]</span><span class="w"></span>
</code></pre></div>

<p>At the moment, there is a check if the file that is linked to ends in a suffix that is a known image suffix, and then it is parsed as an image. If not, you'll get the output below.   </p>
<blockquote>
<p><strong>obsidian-html error:</strong> Obsidian type page inclusion((my note)) (not implemented yet)</p>
</blockquote>
        <!-- end content -->
        </div>
</div>


<script>
        // Init
        // ----------------------------------------------------------------------------
        function LoadPage(){
                console.log('threshold', (1.2 * 40 * getComputedStyle(document.documentElement).fontSize.split("px")[0]));
                SetLinks(0);
        }

        // Scroll container to #header link
        if (window.location.hash != ''){
                let el = document.getElementById(window.location.hash.substr(2));
                if (el){
                        el.parentElement.scrollTop = el.offsetTop - 20;
                }
        }
        
        // Init starting container
        FirstContainer = document.getElementsByClassName('container')[0];
        FirstContainer.id = 'level-0';
        SetContainer(FirstContainer);    
        
        // Open the path on loading the page
        // This is everything after ?path=
        var href = window.location.href;
        var path_to_open = [];
        if (href.includes('?path=')){
                path_to_open = href.split('?path=')[1].split('/');
                for (let i = 0; i < path_to_open.length; i++){
                        path_to_open[i] = decodeURIComponent(path_to_open[i]);
                }
        }        
        OpenPath(1);


        // FUNCTIONS 
        // ----------------------------------------------------------------------------

        function OpenPath(level){
                if (path_to_open.length > 0){
                        let path = path_to_open.shift();
                        if (path != ''){
                                httpGetAsync(path, ReceiveCall, level, true);
                        }
                        
                }       
        }
        
        // Change link operation
        function SetLinks(level){
                size_of_rem = getComputedStyle(document.documentElement).fontSize.split("px")[0];
                if (window.visualViewport.width > (1.2 * 40 * size_of_rem))
                {
                        var links = document.getElementsByTagName('a');
                        for (let i=0; i < links.length; i++){
                                let l = links[i];
                                if (l.id == 'homelink'){
                                        continue;
                                }
                                if (l.classList.contains('external-link')){
                                        continue;
                                }
                                if (l.onclick != null){
                                        continue;
                                }
                                l.onclick = function () { 
                                        httpGetAsync(encodeURI(this.attributes.href.nodeValue), ReceiveCall, level+1, false); 
                                        return false; 
                                };
                        }
                }
        }  
        
        function SetContainer(container)
        {
                // This function is called on every (newly created) container. 
                // One container holds one tab

                // Create clickback element
                cb = document.createElement('div');
                cb.className = 'container-clickback';
                cb.id = 'cb' + container.id;
                container.parentElement.appendChild(cb);
                
                cb.onclick = function () { 
                        cont = document.getElementById(this.id.slice(2))
                        window.scrollTo(Math.max(window.visualViewport.pageLeft - (70 - cont.getBoundingClientRect().left), 0), 0)
                };
        }
        
        function httpGetAsync(theUrl, callback, level, callbackpath)
        {
                var xmlHttp = new XMLHttpRequest();
                xmlHttp.onreadystatechange = function() { 
                        if (xmlHttp.readyState == 4 && xmlHttp.status == 200)
                        callback(xmlHttp, level, theUrl, callbackpath);
                }
                xmlHttp.open("GET", theUrl, true); // true for asynchronous 
                xmlHttp.send(null);
        }

        function ReceiveCall(xmlHttp, level, theUrl, callbackpath){
                respUrl = xmlHttp.responseURL;
                responseText = xmlHttp.responseText;

                // Restore header if it has been hidden because of an anchor link
                document.getElementById('header').style.display = 'block';

                // Set body width to level * 40 rem
                document.body.style.width = (level * 40 + 200) + 'rem';  

                // Get html
                let text = responseText.split('<div class="container">')[1];
                text =  text.split('<!-- end content -->')[0];

                // Close all containers with level below given
                CloseUpperContainers(level);                                

                // Test if container for this level already exists
                // otherwise create
                let levelcont = document.getElementById('level-'+level);
                let isNew = false
                if (levelcont == null) {
                        isNew = true;
                        wrappercont = document.createElement('div');
                        wrappercont.className = 'container-wrapper';
                        wrappercont.id = 'wrapperlevel-'+level;
                        document.body.appendChild(wrappercont);

                        levelcont = document.createElement('div');
                        levelcont.className = 'container';
                        levelcont.id = 'level-'+level;
                }

                // Update content of div
                levelcont.innerHTML = text;

                if (isNew){
                        document.getElementById('wrapperlevel-'+level).appendChild(levelcont);
                }

                // Scroll into view
                levelcont = document.getElementById('level-'+level);
                levelcont.scrollIntoView(true);
                window.scrollTo(window.visualViewport.pageLeft, 0);

                // Scroll container to #header link
                theUrl = decodeURI(theUrl);
                if (theUrl.split('#').length > 1){
                        var el = document.getElementById(theUrl.split('#')[1]);
                        if (el){
                                el.parentElement.scrollTop = el.offsetTop - 20;
                        }
                }
                
                // Arm new links
                SetLinks(level);
                SetContainer(levelcont);

                // Continue path opening (if started with path opening)
                if (callbackpath){
                        OpenPath(level + 1);
                }
                else {
                        // Start to build new href like https://localhost:8000/?path=
                        let new_href = window.location.pathname + '?path=';

                        // Remove https://localhost:8000/ from link name
                        let new_tab = theUrl.replace(window.location.origin+'/', '');

                        // Add in existing path until the tab where was clicked
                        let tab_links = window.location.href.split('?path=');
                        if (tab_links.length > 1){
                                path_to_open = tab_links[1].split('/');
                                for (let i = 0; i < (level - 1); i++){
                                        new_href += path_to_open[i] + '/'
                                }
                        }
                        
                        // Add in new tab
                        new_href += encodeURIComponent(encodeURI(new_tab)) + '/';

                        // Set
                        window.history.pushState({}, "", new_href);
                }
        }

        function CloseUpperContainers(level){
                // Close all containers that are higher in level than the level
                // of the container in which a link was clicked
                let cns = document.getElementsByClassName("container-wrapper");
                for (let i=0; i<cns.length; i++){
                        if (cns[i].id){
                                if (cns[i].id.split('-')[1] > level){
                                        cns[i].remove();
                                        CloseUpperContainers(level);
                                        return;
                                }
                        }
                }
        }
</script>           
</body>
</html>
